# 기본 자료구조

효과적인 프로그램과 동작을 설계하기위해서는 적절한 데이터의 구조가 필요합니다. 기본 자료구조는 프로그래밍에 있어서 가장 기본이되는 자료구조인 선형 자료구조(선형리스트, 연결자료구조, 큐, 스택, 덱)과 비선형 자료구조(트리, 그래프)를 살펴봅니다.
<br/>

## 선형 자료구조
### 선형리스트: 데이터 구조의 가장 기본은 나열
- 원소들 간에 순서를 가진 선형 나열한 순서가 원소들의 순서가 된다.
- **논리적 순서 = 물리적 순서** => **순차 자료구조** Ex) int[]
##### 선형리스트에 원소 삽입
  1.	공간 확보
  2.	위치 이후 원소들 위치 +1
  3.	삽입
##### 선형리스트에 원소 삭제
  1.	삭제
  2.	위치 이후 원소들 위치 -1
  3.	공간 제거


**삽입과 삭제에 추가적인 오버헤드가 발생하기에 삽입과 삭제 연산이 많이 필요한 문제에선 비효율적이다.**
<br/>

### 연결자료구조(비순차 자료구조): 다음 원소에 대한 순서를 표시
- 여러 개의 작은 공간을 연결, 유연성
- 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트
- **노드: 원소와 주소를 갖는 단위구조**
- <원소, 다음 노드 주소> => <원소, 다음 노드 주소> => <원소, null>

##### 노드의 삽입
  0.	생성할 위치를 가리키는 노드를 가져온다.
  1.	생성
  2.	해당 위치의 기존 노드를 새 노드가 가리키게 한다.
  3.	해당 위치의 기존 노드의 앞의 노드가 새 노드를 가리키게 한다.
##### 노드의 삭제
  0.	삭제할 위치를 가리키는 노드를 가져온다.
  1.	삭제할 노드를 가져온다
  2.	삭제할 노드의 앞의 노드가 삭제할 노드의 다음 노드를 가리키게 한다.

**이전 노드를 참조하려면 전체를 다시 한 번 돌아야하는 오버헤드가 발생한다.**
<br/>
### 이중 연결리스트 :  양방향 링크
- 각각의 노드는 자신의 앞과 뒤 참조
- <원소, 다음 노드 주소> <=> <원소, 다음 노드 주소> <=> <원소, null>

##### 노드의 삽입
  0.	생성할 위치에 있던 노드를 가져온다.
  1.	생성
  2.	생성할 위치에 있던 노드를 새 노드가 가리키게 한다.
  3.	생성할 위치에 있던 노드 이전 노드를 새 노드가 가리키게 한다.
  4.	생성할 위치에 있던 노드 이전의 노드가 새 노드를 가리키게 한다.
  5.	생성할 위치에 있던 노드가 새 노드를 가리키게 한다.

##### 노드의 삭제
  0.	삭제할 노드를 찾는다.
  1.	삭제할 노드의 다음 노드가 삭제할 노드의 이전 노드를 가리키게 한다.
  2.	삭제할 노드의 이전 노드가 삭제할 노드의 다음 노드를 가리키게 한다.
<br/>

### 스택:
- 쌓아 올리다.
- Top으로 들어와 Top으로 나간다.
- **후입선출(Last-In-First-Out, LIFO)**

* 고정길이 스택: 순차 자료구조로 구현가능
* 가변길이 스택: 연결리스트로 구현가능
* 변수 top : 가장 위의 값을 저장함.

##### Push (Top으로 넣기)
  0.	Stack의 길이를 초과했는지 확인
  1.	top +1
  2.	top위치에 새 값을 추가
##### Pop (Top으로 빼기)
  0.	Stack이 비어있는지 확인
  1.	top위치의 값을 가져옴
  2.	top -1


#### 스택의 활용 : 후입선출의 특성을 이용한다.
  -	역순 문자열 만들기
  -	시스템 스택 Ex) 메소드 호출, 실행 중 새로운 일을 실행, 해당 일이 종료되면 기존 위치로 복귀
  -	괄호 검사 Ex) ‘{‘는 push ‘}’는 pop
<br/>

### 큐
- Rear로 들어와 Front로 나간다.
- **선입선출(Frist-In-First-Out, FIFO)**

* 고정길이 큐: 순차 자료구조로 구현가능
* 원형 큐: 순차 자료구조 또는 원형 연결리스트로 구현 가능
* 가변길이 큐: 연결리스트로 구현가능

##### enQueue(Rear로 넣기)
  0.	큐의 길이를 초과했는지 확인한다.
  1.	rear +1
  2.	rear위치에 새 값을 넣는다.
##### deQueue(Front로 빼기)
  0.	큐에 원소가 있는지 확인한다.
  1.	front+1
  2.	front위치의 값을 뺀다.

**1차 선형구조의 큐는 큐에 여유공간이 있음에도 사용하지 못한다.**

**= > 원형 구조 0 -> 1 -> 2 -> 3-> 0**
  - 순환을 위해 사용하는 방법 : 나머지 연산
  - 0, 1, 2, 3의 인덱스를 갖는 선형의 마지막 인덱스 3 + 1 & 4 = 0;

#### 큐의 활용: 선입선출의 특성을 이용한다.
  -	스케쥴링

### 덱
- Front와 Rear 모두에서 넣고 빼기가 가능한 자료구조.
- 스택, 큐 모든 성질을 가지고 있다.

* push(), pop(), enQueue(), deQueue() 모두를 구현하면 된다.
<br/>

## 비선형 자료구조
### 트리: 
- 계층적 관계
- 족보
+ **노드: 트리 내 요소**
+ **간선(엣지): 노드 간의 연결선**
+ **루트: 트리의 최상위 레벨(레벨0)의 노드**
+ **조상: 한 노드에서 루트 노드까지의 경로에 있는 모든 노드**
+ **자손: 자식과 자식의 서브 트리의 모든 노드들**
+ **차수:  자식의 수**
+ **리프 노드 : 차수가 0인 노드**

* **포레스트: 트리의 집합, 서브 트리들은 루트를 제거하면 하나의 포레스트를 이룬다.**

#### 이진 트리: 모든 노드의 차수를 2로 제한한 트리. 
- n개의 노드 -> n-1개의 엣지
- h의 높이 -> 최소 h+1개의 노드 최대 2^h+1 -1
- 좌, 우 서브 트리: 두 자식의 각각의 트리를 의미 

#### 순회(Traversal): 모든 노드를 한 번씩 방문해 노드가 가지고 있는 데이터를 처리하는 것

##### 전위(DLR): 자신, 왼쪽, 오른쪽, 재귀적
- 전위 표기식을 구할 수 있다.
0. 자신을 방문한다.
1. 재귀식으로 자신의 왼쪽 노드를 방문한다.
2. 재귀식으로 자신의 오른쪽 노드를 방문한다. 

##### 중위(LDR): 왼쪽, 자신, 오른쪽, 재귀적
- 중의 표기식을 구할 수 있다.
0. 재귀식으로 자신의 왼쪽을 방문한다.
1. 자신을 방문한다.
2. 재귀식으로 자신의 오른쪽을 방문한다.

##### 후위(LRD):왼쪽, 오른쪽, 자신, 재귀적
- 후위 표기식을 구할 수 있다. 
0. 재귀식으로 자신의 왼쪽을 방문한다.
1. 재귀식으로 자신의 오른쪽을 방문한다.
2. 자신을 방문한다.

#### 이진 탐색 트리: 탐색을 위한 자료구조, 저장할 데이터의 크기에 따라 노드의 위치 정의 

-	모든 원소는 유일한 키를 갖는다.
-	왼쪽 서브 트리에 있는 원소의 키는 그 루트의 키보다 작다. 
-	오른쪽 서브 트리에 있는 원소의 키는 그 루트의 키보다 크다
-	왼쪽 서브 트리와 오른쪽 서브 트리도 이진 탐색 트리다. 
+	검색 경우의 수를 2^-1승 가능하다. 

##### 이진 탐색 트리 키 탐색
*	탐색 값 = 루트 노드; => 루트가 탐색 원소
*	탐색 값 < 루트 노드; => 루트 왼쪽 서브 트리 탐색 
*	탐색 값 > 루트 노드; => 루트 오른쪽 서브 트리 탐색

0. 검색 키값과 자신의 키값을 비교해 같으면 자신을 반환한다.
1. 검색 키값이 자신의 키값보다 작을 경우 왼쪽 노드의 검색을 수행한다.(재귀적)
2. 검색 키값이 자신의 키값보다 클 경우 오른쪽 노드에 검색을 수행한다.(재귀적)

##### 이진 탐색 트리 삽입

0. 추가할 키 값으로 검색을 수행해 존재할 경우 삽입을 수행하지 않는다.
1. 임시 변수를 만들어 루트를 할당한다.
2. 반복문으로 좌 우를 탐색하며 비어있는 노드를 찾는다.
2. 비어있는 노드에 새 노드를 삽입한다. 

##### 이진 탐색 트리 삭제

0. 검색

* 삭제할 노드가 리프인 경우
1. 삭제    
* 삭제할 노드가 한 개의 자식만 가지고 있을 경우
1. 삭제할 노드의 위치에 자신의 자식 노드를 대입 한다. 
2. 삭제
* 삭제할 노드가 두 개의 자식 모두를 가지고 있을 경우
1. 삭제할 노드의 좌측 서브 트리의 최우측 노드 또는 삭제할 노드의 우측 서브 트리의 최좌측 노드를 선택한다.
- 최좌측 또는 최우측은 최하단을 의미하지 않는다.
2. 삭제할 노드에 최우측 또는 최좌측 노드를 대입하고, 삭제할 노드의 좌 우 서브 트리를 대체 노드의 좌 우에 각각 대입한다.
 


### 그래프

- 원소들간의 관계를 표현한 
- 정점(Vertex) : 연결할 원소
- 간선(edge) : 연결하는 간선
- G = (V, E) : 그래프는 V개의 정점과 E개의 간선을 갖는다. 
- 차수(degree) : 하나의 정점에 소속된 간선의 수 
- 경로(Path) : 하나의 정점에서 다른 정점까지 간선으로 연결된 정점을 순차적으로 나열한 리스트
- 사이클 : 하나의 정점에서 출발하여 자기 자신으로 돌아오게 되는 경로 
- 
#### 무방향 그래프

-  정점간 간선에 방향이 없는 그래프 
#### 방향 그래프
- 정점간 간선에 방향이 있는 그래프 
- 출발점을 꼬리, 도착점을 머리라고 한다.

##### 완전 그래프 : 한 정점에서 나머지 모든 정점과 연결된 그래프
##### 부분 그래프 : 원래 그래프에서 일부 정점과 간선을 제외한 그래프
##### 가중 그래프 : 간선에 가중치 정보가 있는 그래프