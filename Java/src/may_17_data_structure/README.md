# 기본 자료구조

효과적인 프로그램과 동작을 설계하기위해서는 적절한 데이터의 구조가 필요합니다. 기본 자료구조는 프로그래밍에 있어서 가장 기본이되는 자료구조인 선형 자료구조(선형리스트, 연결자료구조, 큐, 스택, 덱)과 비선형 자료구조(트리, 그래프)를 살펴봅니다.
<br/>

## 선형 자료구조
### 선형리스트: 데이터 구조의 가장 기본은 나열
- 원소들 간에 순서를 가진 선형 나열한 순서가 원소들의 순서가 된다.
- **논리적 순서 = 물리적 순서** => **순차 자료구조** Ex) int[]
##### 선형리스트에 원소 삽입
  1.	공간 확보
  2.	위치 이후 원소들 위치 +1
  3.	삽입
##### 선형리스트에 원소 삭제
  1.	삭제
  2.	위치 이후 원소들 위치 -1
  3.	공간 제거


**삽입과 삭제에 추가적인 오버헤드가 발생하기에 삽입과 삭제 연산이 많이 필요한 문제에선 비효율적이다.**
<br/>

### 연결자료구조(비순차 자료구조): 다음 원소에 대한 순서를 표시
- 여러 개의 작은 공간을 연결, 유연성
- 단순 연결 리스트, 원형 연결 리스트, 이중 연결 리스트, 이중 원형 연결 리스트
- **노드: 원소와 주소를 갖는 단위구조**
- <원소, 다음 노드 주소> => <원소, 다음 노드 주소> => <원소, null>

##### 노드의 삽입
  0.	생성할 위치를 가리키는 노드를 가져온다.
  1.	생성
  2.	해당 위치의 기존 노드를 새 노드가 가리키게 한다.
  3.	해당 위치의 기존 노드의 앞의 노드가 새 노드를 가리키게 한다.
##### 노드의 삭제
  0.	삭제할 위치를 가리키는 노드를 가져온다.
  1.	삭제할 노드를 가져온다
  2.	삭제할 노드의 앞의 노드가 삭제할 노드의 다음 노드를 가리키게 한다.

**이전 노드를 참조하려면 전체를 다시 한 번 돌아야하는 오버헤드가 발생한다.**
<br/>
### 이중 연결리스트 :  양방향 링크
- 각각의 노드는 자신의 앞과 뒤 참조
- <원소, 다음 노드 주소> <=> <원소, 다음 노드 주소> <=> <원소, null>

##### 노드의 삽입
  0.	생성할 위치에 있던 노드를 가져온다.
  1.	생성
  2.	생성할 위치에 있던 노드를 새 노드가 가리키게 한다.
  3.	생성할 위치에 있던 노드 이전 노드를 새 노드가 가리키게 한다.
  4.	생성할 위치에 있던 노드 이전의 노드가 새 노드를 가리키게 한다.
  5.	생성할 위치에 있던 노드가 새 노드를 가리키게 한다.

##### 노드의 삭제
  0.	삭제할 노드를 찾는다.
  1.	삭제할 노드의 다음 노드가 삭제할 노드의 이전 노드를 가리키게 한다.
  2.	삭제할 노드의 이전 노드가 삭제할 노드의 다음 노드를 가리키게 한다.
<br/>

### 스택:
- 쌓아 올리다.
- Top으로 들어와 Top으로 나간다.
- **후입선출(Last-In-First-Out, LIFO)**

* 고정길이 스택: 순차 자료구조로 구현가능
* 가변길이 스택: 연결리스트로 구현가능
* 변수 top : 가장 위의 값을 저장함.

##### Push (Top으로 넣기)
  0.	Stack의 길이를 초과했는지 확인
  1.	top +1
  2.	top위치에 새 값을 추가
##### Pop (Top으로 빼기)
  0.	Stack이 비어있는지 확인
  1.	top위치의 값을 가져옴
  2.	top -1


#### 스택의 활용 : 후입선출의 특성을 이용한다.
  -	역순 문자열 만들기
  -	시스템 스택 Ex) 메소드 호출, 실행 중 새로운 일을 실행, 해당 일이 종료되면 기존 위치로 복귀
  -	괄호 검사 Ex) ‘{‘는 push ‘}’는 pop
<br/>

### 큐
- Rear로 들어와 Front로 나간다.
- **선입선출(Frist-In-First-Out, FIFO)**

* 고정길이 큐: 순차 자료구조로 구현가능
* 원형 큐: 순차 자료구조 또는 원형 연결리스트로 구현 가능
* 가변길이 큐: 연결리스트로 구현가능

##### enQueue(Rear로 넣기)
  0.	큐의 길이를 초과했는지 확인한다.
  1.	rear +1
  2.	rear위치에 새 값을 넣는다.
##### deQueue(Front로 빼기)
  0.	큐에 원소가 있는지 확인한다.
  1.	front+1
  2.	front위치의 값을 뺀다.

**1차 선형구조의 큐는 큐에 여유공간이 있음에도 사용하지 못한다.**

**= > 원형 구조 0 -> 1 -> 2 -> 3-> 0**
  - 순환을 위해 사용하는 방법 : 나머지 연산
  - 0, 1, 2, 3의 인덱스를 갖는 선형의 마지막 인덱스 3 + 1 & 4 = 0;

#### 큐의 활용: 선입선출의 특성을 이용한다.
  -	스케쥴링

### 덱
- Front와 Rear 모두에서 넣고 빼기가 가능한 자료구조.
- 스택, 큐 모든 성질을 가지고 있다.

* push(), pop(), enQueue(), deQueue() 모두를 구현하면 된다.
